;関数置き場
;-------------------------------------------------
;道具販売状況@ITEMSTOCK
;戻り値1 道具が存在しない
;戻り値2 売切
;戻り値3 お金が足りない
;戻り値4 条件を満たしていない
;戻り値5 すでに99個所持している
;-------------------------------------------------
@ITEMSTOCK(ARG)
#FUNCTION
SIF !STRLENS(ITEMNAME:ARG)
	RETURNF 1
SIF ITEMSALES:ARG == -2
	RETURNF 4
SIF ITEMSALES:ARG == -1
	RETURNF 2
SIF (MONEY < ITEMPRICE:ARG && !TFLAG:194) || (TFLAG:194 == 1 && MONEY < ITEMPRICE:ARG / 3)
	RETURNF 3
SIF ITEM:ARG >= 99
	RETURNF 5
RETURNF 0

;-------------------------------------------------
;関数名:CHOICE
;概　要:２～４択関数
;引　数:ARGS:0…質問内容
;      :ARGS:1～4…選択肢の文字列(3,4は省略可)
;戻り値:ユーザ入力結果(0～3)
;選択条件の無い、シンプルな選択肢作成関数
;口上とかでも使えるかもしれない
;とりあえず4択まで。増やしてもいいけど
;-------------------------------------------------
@CHOICE(ARGS:0, ARGS:1, ARGS:2, ARGS:3, ARGS:4)
PRINTSL ARGS:0
FOR LOCAL, 0, 4
	PRINTFORML [{LOCAL}] - %ARGS:(1 + LOCAL)%
	SIF LOCAL && !STRLENS(ARGS:(2 + LOCAL))
		BREAK
NEXT
$INPUT_LOOP
INPUT
SELECTCASE RESULT
	CASE 0 TO LOCAL - 1
	CASEELSE
		CALL SIMATTYAUOJISAN
		CLEARLINE 1
		GOTO INPUT_LOOP
ENDSELECT
RETURN RESULT
;-------------------------------------------------
;選択肢を表示し入力結果を返す関数 条件を満たさない選択肢をグレー表示にして無効にすることが可能
;引数にセリフと条件(0で無効、非0で有効)を指定。最大5個まで
;戻り値は選択した選択肢の番号
;-------------------------------------------------
@ASK_M(ARGS:0, ARG:0, ARGS:1, ARG:1, ARGS:2, ARG:2, ARGS:3, ARG:3, ARGS:4, ARG:4, ARGS:5, ARG:5)
CURRENTREDRAW
LOCAL:0 = RESULT
REDRAW 0
FOR LOCAL:0, 0, 6
	IF ARGS:(LOCAL:0) != ""
		IF ARG:(LOCAL:0)
			PRINTBUTTON @"{LOCAL:0, 2, RIGHT}[%ARGS:(LOCAL:0)%]", LOCAL:0
		ELSE
			SETCOLOR 0x606060
			PRINTPLAINFORM {LOCAL:0, 2, RIGHT}[%ARGS:(LOCAL:0)%]
			RESETCOLOR
		ENDIF
		PRINTL 
	ENDIF
NEXT
$INPUT_LOOP
INPUT
IF RESULT < 0 || RESULT > 5 || ARGS:RESULT == "" || !ARG:RESULT
	CLEARLINE 1
	GOTO INPUT_LOOP
ENDIF
REDRAW LOCAL:0
RETURN RESULT
;-------------------------------------------------
;現金とカリスマどちらでも払える選択肢のための関数
;-------------------------------------------------
@PAY_YEN_OR_CM(ARG,ARG:1)
PRINTFORML [0] 放弃
PRINTFORML [1] 支付\\{ARG}　　（現在的所持金：\\{MONEY}）
PRINTFORML [2] 支付CM{ARG:1}　（現在的所持籌碼：CM{MONEY:2}）
$INPUT_LOOP
INPUT
SELECTCASE RESULT
	CASE 0
	CASE 1
		IF MONEY < ARG
			PRINTFORMW 金钱不足
			GOTO INPUT_LOOP
		ENDIF
		MONEY -= ARG
	CASE 2
		IF MONEY < ARG:2
			PRINTFORMW 籌碼不足
			GOTO INPUT_LOOP
		ENDIF
		MONEY -= ARG:2
	CASEELSE
		GOTO INPUT_LOOP
ENDSELECT
RETURN RESULT
;-------------------------------------------------
;関数名:GET_REVISION
;概　要:汎用補正値取得関数
;引　数:ARG:0…参照する数値
;戻り値:補正後の値
;備　考:式中関数
;ある数値を、上限値に漸近していく数値に変換したいときに
;上昇率が小さいとすぐに上限に達する、大きいと逆になかなか上限まで近づかない
;-------------------------------------------------
@GET_REVISION(ARG:0, 上限, 上昇率)
#FUNCTION
#DIM 上限
#DIM 上昇率
RETURNF 上限 - 上昇率 * 上限 / (上昇率 + ARG:0)

;eg 10000,2000,20000だと2000-2000*20000/30000

@GET_REVISION2(ARG:0, 上限, 上昇率)
#FUNCTION
#DIM 上限
#DIM 上昇率
RETURNF 上限 * (ARG:0 + 1) / (上昇率 + ARG:0 + 1)

;eg 5000*1001/1201

;-------------------------------------------------
;関数名:PRINT_BASE
;概　要:汎用補正値取得関数
;引　数:ARGS バーの名前
;		ARG:0…参照するキャラ番号
;       ARG:1…ベースの番号
;       ARG:2…バーの長さ
;BARを表示させたいときに
;-------------------------------------------------
@PRINT_BASE(ARGS,ARG:0,ARG:1,ARG:2)
PRINTFORM %ARGS,%
BAR BASE:ARG:(ARG:1),MAXBASE:ARG:(ARG:1),ARG:2
PRINTFORML ({BASE:ARG:(ARG:1)}/{MAXBASE:ARG:(ARG:1)})

;FileName_COMMON.ERB ------------------------------- Rev1.00
;文字入りライン表示関数
;CALL		USER
;ARG		ARGS:表示ライン名, ARG:0 line_to_"-", ARG:1 ライン長
;RETURN		VOID
;COMMENT	
;-----------------------------------------------------------
@DRAW_INFORMATIONLINE(ARGS,ARG,ARG:1)
#DIMS EQUAL
#DIMS MINUS
EQUAL = =
MINUS = -
LOCAL = ARG:1

IF ARGS =="Info"
	SIF TFLAG:Info表示中
		RETURN
	TFLAG:Info表示中 = 1
ENDIF
SIF !ARG:1
	LOCAL = 150
IF ARG == 1
	PRINTSINGLEFORMS "-- %ARGS% " + "%(MINUS * MAX((LOCAL - STRLENS(ARGS)),0))%"
ELSE
	PRINTSINGLEFORMS "== %ARGS% " + "%(EQUAL * 150)%"
ENDIF

;-------------------------------------------------
;未読判定関数@ONCE
;式中で使用する関数です
;ARGSはイベント番号、ARGは真だと初回判定を更新しない、ARG:1はキャラ登録番号（省略するとTARGET,-1ならMASTER）
;{イベント番号}/　という文字列をCSTR:1にぶっこんでいきます
;-------------------------------------------------
@ONCE(ARGS,ARG, ARG:1)
#FUNCTION
;ARG:2の変換
ARG:1 = ARG:1 ? ARG:1 # TARGET
ARG:1 = ARG:1 == -1 ? MASTER # ARG:1

SIF CSTR:(ARG:1):1 == ""
	CSTR:(ARG:1):1 = /

LOCALS = /%ARGS%/
IF STRCOUNT(CSTR:(ARG:1):1,LOCALS)
	RETURNF 0
ELSEIF ARG
	RETURNF 1
ENDIF
;初回判定更新
CSTR:(ARG:1):1 = %CSTR:(ARG:1):1%%ARGS%/
RETURNF 1

;FileName_COMMON.ERB ------------------------------- Rev1.00
;フラグリセット処理
;CALL		SYSTEM
;ARG		VOID
;RETURN		VOID
;COMMENT	
;-----------------------------------------------------------
@EVENTTRAIN
FOR LOCAL,0,CHARANUM
	CSTR:LOCAL:1 = 
NEXT

;-------------------------------------------------
;未読判定関数@FIRSTTIME
;式中で使用する関数です。
;ARGSはイベント番号、ARGは真だと初回判定を更新しない、ARG:1はキャラ登録番号（省略するとTARGET,-1ならMASTER）
;{イベント番号}/　という文字列をCSTR:0にぶっこんでいきます
;-------------------------------------------------
@FIRSTTIME(ARGS,ARG, ARG:1)
#FUNCTION
;ARG:1の変換
ARG:1 = ARG:1 ? ARG:1 # TARGET
ARG:1 = ARG:1 == -1 ? MASTER # ARG:1
SIF CSTR:(ARG:1):0 == ""
	CSTR:(ARG:1):0 = /

LOCALS = /%ARGS%/
IF STRCOUNT(CSTR:(ARG:1):0,LOCALS)
	RETURNF 0
ELSEIF ARG
	RETURNF 1
ENDIF
;初回判定更新
CSTR:(ARG:1):0 = %CSTR:(ARG:1):0%%ARGS%/
RETURNF 1

;-------------------------------------------------
;関数名:EXP_UP
;概　要:経験値変動チェック
;引　数:ARG:0…参照するEXP
;       ARG:1…参照するキャラ番号
;-------------------------------------------------
@EXP_UP(ARG,ARG:1)
#FUNCTION
RETURNF EXP:(ARG:1):ARG - TCVAR:(ARG:1):(400 + ARG)

;-------------------------------------------------
;関数名:INVAGINA
;概　要:Vに何が入っているのかを返す
;引　数:ARG:0…参照するキャラ番号
;戻り値:0なし
;戻り値:1 ペニス
;戻り値:2 振動棒
;-------------------------------------------------
@INVAGINA(ARG)
#FUNCTION
IF TEQUIP:ARG:50
	IF TALENT:PLAYER:2 & 2
		RETURNF 1
	ELSE
		RETURNF 3
	ENDIF
ELSEIF TEQUIP:ARG:振動棒
	RETURNF 2
ENDIF
;-------------------------------------------------
;関数名:INANAL
;概　要:Aに何が入っているのかを返す
;引　数:ARG:0…参照するキャラ番号
;戻り値:0なし
;戻り値:1 ペニス
;戻り値:2 肛用振動棒
;戻り値:3 後庭拉珠
;-------------------------------------------------
@INANAL(ARG)
#FUNCTION
IF TEQUIP:ARG:51
	RETURNF 1
ELSEIF TEQUIP:ARG:肛用振動棒
	RETURNF 2
ELSEIF TEQUIP:ARG:後庭拉珠
	RETURNF 3
ENDIF
;-------------------------------------------------
;関数名:HETEROSEX
;ARGとARG:1の性別が同じかどうかを返すほんとはHOMOSEXだけど語感が悪いので
;女性器を持つものは女、持たないものを男とする
;戻り値0=異性
;戻り値1=同性(レズ)
;戻り値2=同性(ゲイ)
;-------------------------------------------------
@HETEROSEX(ARG,ARG:1)
#FUNCTION
IF GETBIT(TALENT:ARG:2,0) == GETBIT(TALENT:(ARG:1):2,0)
	IF GETBIT(TALENT:ARG:2,0)
		RETURNF 1
	ELSE
		RETURNF 2
	ENDIF
ELSE
	RETURNF 0
ENDIF

;-------------------------------------------------
;関数名:GET_TARGETNUM
;同室中のTARGETの数を返す
;ARG: 1=霊廟メンバーもカウントする, 2=霊廟メンバーのみカウントする
;-------------------------------------------------
@GET_TARGETNUM(ARG)
#FUNCTION
VARSET LOCAL
IF ARG != 2
	FOR LOCAL,1,CHARANUM
		SIF TARGET:LOCAL > 0
			LOCAL:1 ++
	NEXT
ENDIF
IF ARG
	FOR LOCAL,201,206
		SIF TFLAG:LOCAL == CFLAG:MASTER:現在位置
			LOCAL:1 ++
	NEXT
ENDIF
RETURNF LOCAL:1
;-------------------------------------------------
;関数名:IN_ROOM_MEMBER
;部屋の中で特定要素での最低・最高を持つキャラを取得
;ARGS MAXかMINかを選択
;ARG 部屋の番号
;ARGS:1 対象となる変数の名前
;ARG:1 変数の番号
;-------------------------------------------------
@IN_ROOM_MEMBER, ARGS, ARG, ARGS:1, ARG:1
#FUNCTION
VARSET LOCAL, 0
SELECTCASE ARGS:1
	CASE "CFLAG"
		FOR LOCAL, 1, CHARANUM
			SIF CFLAG:LOCAL:現在位置 != ARG
				CONTINUE
			IF LOCAL:3++ == 0
				LOCAL:1 = CFLAG:LOCAL:(ARG:1)
				LOCAL:2 = LOCAL
			ELSEIF ARGS == "MAX" && LOCAL:1 < CFLAG:LOCAL:(ARG:1)
				LOCAL:1 = CFLAG:LOCAL:(ARG:1)
				LOCAL:2 = LOCAL
			ELSEIF ARGS == "MIN" && LOCAL:1 > CFLAG:LOCAL:(ARG:1)
				LOCAL:1 = CFLAG:LOCAL:(ARG:1)
				LOCAL:2 = LOCAL
			ELSEIF LOCAL:1 == CFLAG:LOCAL:(ARG:1) && RAND:2
				LOCAL:1 = CFLAG:LOCAL:(ARG:1)
				LOCAL:2 = LOCAL
			ENDIF
		NEXT
		RETURNF LOCAL:2
	CASE "TCVAR"
		FOR LOCAL, 1, CHARANUM
			SIF CFLAG:LOCAL:現在位置 != ARG
				CONTINUE
			IF LOCAL:3++ == 0
				LOCAL:1 = TCVAR:LOCAL:(ARG:1)
				LOCAL:2 = LOCAL
			ELSEIF ARGS == "MAX" && LOCAL:1 < TCVAR:LOCAL:(ARG:1)
				LOCAL:1 = TCVAR:LOCAL:(ARG:1)
				LOCAL:2 = LOCAL
			ELSEIF ARGS == "MIN" && LOCAL:1 > TCVAR:LOCAL:(ARG:1)
				LOCAL:1 = TCVAR:LOCAL:(ARG:1)
				LOCAL:2 = LOCAL
			ELSEIF LOCAL:1 == TCVAR:LOCAL:(ARG:1) && RAND:2
				LOCAL:1 = TCVAR:LOCAL:(ARG:1)
				LOCAL:2 = LOCAL
			ENDIF
		NEXT
		RETURNF LOCAL:2
	CASE "ABL"
		FOR LOCAL, 1, CHARANUM
			SIF CFLAG:LOCAL:現在位置 != ARG
				CONTINUE
			IF LOCAL:3++ == 0
				LOCAL:1 = ABL:LOCAL:(ARG:1)
				LOCAL:2 = LOCAL
			ELSEIF ARGS == "MAX" && LOCAL:1 < ABL:LOCAL:(ARG:1)
				LOCAL:1 = ABL:LOCAL:(ARG:1)
				LOCAL:2 = LOCAL
			ELSEIF ARGS == "MIN" && LOCAL:1 > ABL:LOCAL:(ARG:1)
				LOCAL:1 = ABL:LOCAL:(ARG:1)
				LOCAL:2 = LOCAL
			ELSEIF LOCAL:1 == ABL:LOCAL:(ARG:1) && RAND:2
				LOCAL:1 = ABL:LOCAL:(ARG:1)
				LOCAL:2 = LOCAL
			ENDIF
		NEXT
		RETURNF LOCAL:2
	CASE "TALENT"
		FOR LOCAL, 1, CHARANUM
			SIF CFLAG:LOCAL:現在位置 != ARG
				CONTINUE
			IF LOCAL:3++ == 0
				LOCAL:1 = TALENT:LOCAL:(ARG:1)
				LOCAL:2 = LOCAL
			ELSEIF ARGS == "MAX" && LOCAL:1 < TALENT:LOCAL:(ARG:1)
				LOCAL:1 = TALENT:LOCAL:(ARG:1)
				LOCAL:2 = LOCAL
			ELSEIF ARGS == "MIN" && LOCAL:1 > TALENT:LOCAL:(ARG:1)
				LOCAL:1 = TALENT:LOCAL:(ARG:1)
				LOCAL:2 = LOCAL
			ELSEIF LOCAL:1 == TALENT:LOCAL:(ARG:1) && RAND:2
				LOCAL:1 = TALENT:LOCAL:(ARG:1)
				LOCAL:2 = LOCAL
			ENDIF
		NEXT
		RETURNF LOCAL:2
ENDSELECT
;FileName_COMMON.ERB ------------------------------- Rev1.00
;TARGET再設定関数
;CALL		USER
;ARG		VOID
;RETURN		VOID
;COMMENT	
;-----------------------------------------------------------
;
;リスト関数とソート関数ができたのでかなり簡易化できたかな
@TARGETSET_CHACK(OP)
#DIMS OP         ;SHOW_STATUSは同室更新入れるとマズイのでスキップする用
#DIM  TARGET_CNT ;ターゲットの数
#DIM  L_ID       ;REF対策、渡すだけ
#DIM  SWAP_ID    ;現在のTARGET指定処理用の一時変数
;うふふ中はTARGETを逃がす（情事発覚とかでズレちゃうので）
SIF !TFLAG:現在のTARGET && (CFLAG:TARGET:うふふ || CFLAG:MASTER:お招き)
	TFLAG:現在のTARGET = TARGET

CALL MAKE_CHARA_LIST("TARGETリスト", L_ID, TARGET, TARGET_CNT)
SIF !TARGET_CNT
	RETURN
CALL SORT_LIST("好感降順", TARGET, TARGET_CNT)

LOCAL:1 = TARGET
IF TFLAG:現在のTARGET > 0
	LOCAL:1 = FINDELEMENT(TARGET, TFLAG:現在のTARGET)
	IF LOCAL:1 == -1
		LOCAL:1 = 0
		TFLAG:現在のTARGET = 0
	ENDIF
	LOCAL:1 = TARGET:(LOCAL:1)
ENDIF
ARRAYSHIFT TARGET, 1, LOCAL:1

SIF STRCOUNT(OP, "「同室更新無し」")
	RETURN

;同室確認はリスト側でやっているのでここでは必要ない
FOR LOCAL, 1, 1 + TARGET_CNT
	CFLAG:(TARGET:LOCAL):同室 = 1
NEXT



[SKIPSTART]
@TARGETSET_CHACK
VARSET LOCAL
;うふふ中はTARGETを逃がす（情事発覚とかでズレちゃうので）
SIF !TFLAG:104 && (CFLAG:TARGET:うふふ || CFLAG:MASTER:お招き)
	TFLAG:104 = TARGET

;同室中のキャラをTARGETに代入
VARSET TARGET
;キャラを好感度の昇順に並び替え
CALL SORT_CFLAG(2)
FOR LOCAL,1,CHARANUM
	SIF CFLAG:MASTER:現在位置 != CFLAG:(RESULT:LOCAL):現在位置
		CONTINUE
	LOCAL:1 ++
	TARGET:(LOCAL:1) = RESULT:LOCAL
NEXT

;TFLAG:104が設定されているときその番号のターゲットが存在するならTARGETに代入、いなければTFLAG:104をリセット
LOCAL:1 = 0
TARGET = TARGET:1
FOR LOCAL,1,CHARANUM
	SIF TFLAG:104 < 1
		BREAK
	IF TARGET:LOCAL == TFLAG:104
		TARGET = TARGET:LOCAL
		LOCAL:1 ++
	ENDIF
NEXT
SIF !LOCAL:1
	TFLAG:104 = 0
;同室フラグ立て直し
FOR LOCAL,1,CHARANUM
	SIF TARGET:LOCAL <= 0
		BREAK
	IF CFLAG:(TARGET:LOCAL):現在位置 == CFLAG:MASTER:現在位置
		CFLAG:(TARGET:LOCAL):同室 = 1
	ELSE
		CFLAG:(TARGET:LOCAL):同室 = 0
	ENDIF
NEXT
[SKIPEND]

;FileName_COMMON.ERB ------------------------------- Rev1.00
;デート道中進行
;CALL		USER
;ARG		進める時間（10分単位）
;RETURN		VOID
;COMMENT	
;-----------------------------------------------------------
@DATE_GOES_ON(ARG)
IF (CFLAG:MASTER:現在位置 % 100) % 10 && !AT_HOME(MASTER) && CFLAG:MASTER:現在位置 != OMANEKIBEYA()
	IF (CFLAG:MASTER:現在位置 % 100 % 10) - ARG < 0
		LOCAL:1 = CFLAG:MASTER:現在位置 - (CFLAG:MASTER:現在位置 % 100 % 10)
	ELSE
		LOCAL:1 = CFLAG:現在位置 - ARG
	ENDIF
	FOR LOCAL,0,CHARANUM
		SIF CHK_DATENOW(CFLAG:LOCAL:デート中)
			CFLAG:LOCAL:現在位置 = LOCAL:1
	NEXT
ENDIF
;====================================================
@性技補正(ARG)
#FUNCTION
RETURNF 1 + (ABL:PLAYER:ARG - 2) / 10
;====================================================

;-------------------------------------------------
;関数名:RECOVER
;概　要:BASE回復処理
;引　数:ARGS
;		ARG:0…参照するキャラ番号
;		ARG:1…回復量
;       ARGS…ベース
;		ARGS:1	表示付き
;-------------------------------------------------
@RECOVER(ARG,ARG:1,ARGS,ARGS:1)
#DIM  BASE_ID
BASE_ID = FINDELEMENT(BASENAME, ARGS)
BASE:ARG:(ARGS) = LIMIT(BASE:ARG:(ARGS) + ARG:1, 0, MAXBASE:ARG:(ARGS))
IF ARGS != ""
	IF ARG:1 > 0
		CALL COLORMESSAGE(@"%BASENAME:BASE_ID%＋{ARG:1} （%CALLNAME:ARG%）",C_GREEN,1)
	ELSE
		CALL COLORMESSAGE(@"%BASENAME:BASE_ID%－{ARG:1 * -1} （%CALLNAME:ARG%）",C_RED,1)
	ENDIF
ENDIF

;-------------------------------------------------
;関数名:RECOVER_PERMIL
;概　要:BASE割合回復処理
;引　数:ARGS
;		ARG:0…参照するキャラ番号
;       ARGS…ベース
;回復量は0.1%単位
;-------------------------------------------------
@RECOVER_PERMIL(ARG,回復量,ARGS,回復速度の影響)
#DIM 回復量
#DIM 回復速度の影響
SIF !TALENT:ARG:2 & 2 && ARGS == "精力"
	回復量 = 0
LOCAL = MAXBASE:ARG:(ARGS) * 回復量 / 1000
SIF 回復速度の影響
	LOCAL = LOCAL * (TALENT:ARG:回復速度 + 4) / 4
BASE:ARG:(ARGS) = LIMIT(BASE:ARG:(ARGS) + LOCAL, 0, MAXBASE:ARG:(ARGS))

;-------------------------------------------------
;関数名:BUFF_BASE
;概　要:特定BASEを一時的に強化
;-------------------------------------------------
@BUFF_BASE(ARG,強化能力,変動値)
#DIM 変動値
#DIM 強化能力
SIF !TALENT:ARG:2 & 2 && 強化能力 == 6
	変動値 = 0
SIF 変動値 < 0 && ABS(変動値) > MAXBASE:ARG:強化能力
	変動値 = MAXBASE:ARG:強化能力 * -1

MAXBASE:ARG:強化能力 += 変動値
BASE:ARG:強化能力 += 変動値
BUFF:ARG:強化能力 += 変動値

;-------------------------------------------------
;関数名:BUFF_RESET
;概　要:バフを完全にリセット
;-------------------------------------------------
@BUFF_RESET
FOR LOCAL,0,CHARANUM
	FOR LOCAL:1, 0, 16
		MAXBASE:LOCAL:(LOCAL:1) -= BUFF:LOCAL:(LOCAL:1)
		BASE:LOCAL:(LOCAL:1) -= BUFF:LOCAL:(LOCAL:1)
		BUFF:LOCAL:(LOCAL:1) = 0
	NEXT
NEXT

;-------------------------------------------------
;関数名:CHANGE_CFLAG
;概　要:メッセージ付きCFLAG変動
;舞茄子にはならないようになってるので注意
;-------------------------------------------------
@CHANGE_CFLAG(変動フラグ,対象,変動数)
#DIM 変動フラグ
#DIM 対象
#DIM 変動数

CFLAG:対象:変動フラグ = MAX(CFLAG:対象:変動フラグ + 変動数, 0)
IF 変動数 > 0
	CALL COLORMESSAGE(@"%CFLAGNAME:変動フラグ%＋{変動数}（%CALLNAME:対象%）",C_YELLOW,2,1)
ELSE
	CALL COLORMESSAGE(@"%CFLAGNAME:変動フラグ%－{-変動数}（%CALLNAME:対象%）",C_RED,2,1)
ENDIF
;-------------------------------------------------
;関数名:SHIRAHU
;概　要:普通に意識がある状態か　2だとウフフ中
;-------------------------------------------------
@SHIRAHU(ARG)
#FUNCTION
IF FLAG:70
	RETURNF 0
ELSEIF !CFLAG:ARG:睡眠 && !CFLAG:ARG:添い寝中 && !TCVAR:ARG:泥酔 && !CFLAG:ARG:衰弱
	IF TFLAG:102 == 2
		RETURNF 2
	ELSE
		RETURNF 1
	ENDIF
ELSE
	RETURNF 0
ENDIF

;-------------------------------------------------
;関数名:BETWEENTIME
;概　要:TIMEがARGからARG:1までの間なのか返す関数
;-------------------------------------------------
@BETWEENTIME(ARG,ARG:1)
#FUNCTION
IF ARG < ARG:1
	IF TIME >= ARG && TIME < ARG:1
		RETURNF 1
	ELSE
		RETURNF 0
	ENDIF
ELSE
	IF TIME >= ARG || TIME < ARG:1
		RETURNF 1
	ELSE
		RETURNF 0
	ENDIF
ENDIF
;-------------------------------------------------
;関数名:VISIT
;概　要:そのキャラの活動時間帯かどうかを返す関数
;-------------------------------------------------
@VISIT(ARG)
#FUNCTION
RETURNF BETWEENTIME(CFLAG:ARG:来訪時間,CFLAG:ARG:帰宅時間)
;-------------------------------------------------
;関数名:睡眠時間
;概　要:住み込みキャラが寝てるかどうかを返す関数だったのを全員使えるように
;寝てると1を返す
;-------------------------------------------------
@睡眠時間(ARG)
#FUNCTION
SIF ARG == MASTER
	RETURNF CFLAG:MASTER:睡眠
IF CFLAG:ARG:衰弱
	RETURNF 1
ELSEIF !BETWEENTIME(CFLAG:ARG:起床時間, CFLAG:ARG:就寝時間)
	RETURNF 1
ELSE
	RETURNF 0
ENDIF
;-------------------------------------------------
;関数名:WORKING
;概　要:そのキャラの仕事時間帯かどうかを返す関数
;-------------------------------------------------
@WORKING(ARG)
#FUNCTION
IF !SHIRAHU(ARG)
	RETURNF 0
ELSEIF !BETWEENTIME(TCVAR:ARG:仕事開始,TCVAR:ARG:仕事終了)
	RETURNF 0
ELSEIF BASE:ARG:工作量 <= 0
	RETURNF 0
ELSEIF CHARA_HOLIDAY(ARG)
	RETURNF 0
ELSE
	RETURNF 1
ENDIF
;-------------------------------------------------
;関数名:連続実行
;概　要:同一コマンド連続実行した際ペナルティが発生するか
;戻り値:0だとペナが発生しない
;-------------------------------------------------
@連続実行()
#FUNCTION
SELECTCASE PREVCOM
	CASE 1,60,61,65,67,68,300,304,410,604,621
		RETURNF 0
	CASEELSE
		RETURNF 1
ENDSELECT

;-------------------------------------------------
;関数名:カウンター不発コマンド
;戻り値:0でないとカウンター不発
;-------------------------------------------------
@カウンター不発コマンド(ARG)
#FUNCTION
SELECTCASE ARG
	CASE 697 TO 699
		RETURNF 1
	CASEELSE
		RETURNF 0
ENDSELECT
;-------------------------------------------------
;関数名:ENDUFUFU
;概　要:うふふ終了時リセット処理
;-------------------------------------------------
@ENDUFUFU(ARG)
IF FLAG:70 == 1 || CFLAG:ARG:衣装一時変更
	;時間停止中は服装セットしない
ELSEIF LOCK:(CFLAG:ARG:初期位置) && CFLAG:ARG:睡眠
	;睡眠中ならパジャマセット
	CALL CTRL_CLOTHES_SET(ARG, "現在衣装の変更_パジャマ")
	CFLAG:ARG:パジャマ = 1
ELSE
	;イタズラ以外なら普段着セット
	CALL CTRL_CLOTHES_SET(ARG, "現在衣装の変更_普段着")
	CFLAG:ARG:パジャマ = 0
ENDIF
;服装をTEQUIPへ
CALL CLOTHES_SETTING_TRAIN(ARG)

;ウフフ時系装備リセット
;TEQUIP:ARG:10-TEQUIP:ARG:149を初期化する
VARSET TEQUIP:ARG:0, 0, 10, 150
;FOR ARG:1,10,150
;	TEQUIP:ARG:(ARG:1) = 0
;NEXT

;射精関係リセット
IF TFLAG:102 < 2
	BASE:ARG:射精 = 0
	TCVAR:ARG:イきそう = 0
ENDIF
CFLAG:ARG:うふふ = 0
TEQUIP:ARG:50 = -1
TEQUIP:ARG:51 = -1
TEQUIP:ARG:上半身はだけ状態 = 0
TEQUIP:ARG:下半身ずらし状態 = 0
TCVAR:ARG:無理矢理 = 0
TCVAR:ARG:好きにして = 0

;一応MASTERも初期化（しとかないと、終了後も○○装着中が表示される可能性があるので
IF CFLAG:MASTER:うふふ
	CFLAG:MASTER:うふふ = 0
	VARSET TEQUIP:MASTER:0, 0, 10, 150
	TEQUIP:MASTER:50 = -1
	TEQUIP:MASTER:51 = -1
	TEQUIP:MASTER:上半身はだけ状態 = 0
	TEQUIP:MASTER:下半身ずらし状態 = 0
ENDIF

IF CFLAG:睡眠
	IF CFLAG:ARG:口に精液
		PRINTFORML %CALLNAME:MASTER%処理掉了%CALLNAME:ARG%口中残留的精液
		CFLAG:ARG:口に精液 = 0
	ENDIF
	IF CFLAG:ARG:顔に精液 || CFLAG:ARG:手に精液
		PRINTFORM %CALLNAME:MASTER%把粘在%CALLNAME:ARG%
		IF CFLAG:ARG:顔に精液 && !CFLAG:ARG:手に精液
			PRINTFORM 脸上的
		ELSEIF !CFLAG:ARG:顔に精液 && CFLAG:ARG:手に精液
			PRINTFORM 手上的
		ELSE
			PRINTFORM 脸和手上的
		ENDIF
		PRINTFORML 精液擦拭掉了
		CFLAG:ARG:顔に精液 = 0
		CFLAG:ARG:手に精液 = 0
	ENDIF
ENDIF
IF !FLAG:70
	TFLAG:運搬 = 0
	IF CFLAG:ARG:口に精液
		PRINTFORML %CALLNAME:ARG%把嘴里残留着的精液\@ ABL:ARG:精液中毒 > 2 ? 喝下去了 # 吐出来了 \@
		CFLAG:ARG:口に精液 = 0
	ENDIF
	IF CFLAG:ARG:顔に精液 || CFLAG:ARG:手に精液
		PRINTFORM %CALLNAME:ARG%
		IF CFLAG:ARG:顔に精液 && !CFLAG:ARG:手に精液
			PRINTFORM 脸上的
		ELSEIF !CFLAG:ARG:顔に精液 && CFLAG:ARG:手に精液
			PRINTFORM 手上的
		ELSE
			PRINTFORM 脸和手上的
		ENDIF
		PRINTFORML 把精液\@ ABL:ARG:精液中毒 > 2 ? 含进嘴里 # 擦掉了 \@
		CFLAG:ARG:顔に精液 = 0
		CFLAG:ARG:手に精液 = 0
	ENDIF
ENDIF
;-------------------------------------------------------------
;ARGと主人公が同性だった場合、両者にレズ（ゲイ）経験を追加する関数
;-------------------------------------------------------------
@ADD_EXP_LESNIAN(UP_EXP,ARG,ARGS)
#DIM UP_EXP
#DIM SAMESEX

;第二引数を省略するとTARGET扱い
SIF !ARG
	ARG = TARGET
IF HETEROSEX(ARG,MASTER)
	SAMESEX = 50 + HETEROSEX(ARG,MASTER)
	EXP:SAMESEX += UP_EXP
	EXP:PLAYER:SAMESEX += UP_EXP
	IF ARGS != ""
		CALL COLORMESSAGE(@"%EXPNAME:SAMESEX%＋{UP_EXP}（%CALLNAME:ARG%）",C_YELLOW,2,1)
		CALL COLORMESSAGE(@"%EXPNAME:SAMESEX%＋{UP_EXP}（%CALLNAME:MASTER%）",C_YELLOW,2,1)
	ENDIF
ENDIF


;-------------------------------------------------
;イベントなどでキレた場合の処理
;-------------------------------------------------
@GET_ANGRY(ARG)
CFLAG:ARG:心情不快 = 1
CFLAG:ARG:ブチギレ = 1
TALENT:ARG:心情 = -1

;FileName_COMMON.ERB ------------------------------- Rev1.00
;酒酔い状態取得
;CALL		USER
;ARG		キャラNo
;RETURN		酒酔い状態_toSTR
;COMMENT	
;-----------------------------------------------------------
@ALCOHOL_FACE(ARG)
#FUNCTIONS
SIF BASE:ARG:酒気 <= 2
	RETURNF "　素面　"
SELECTCASE BASE:ARG:酒気
	CASE IS > (MAXBASE:ARG:酒気 / 10) * 8
		RETURNF "ぐでぐで"
;	CASE IS > (MAXBASE:ARG:酒気 / 10) * 7
;		RETURNF "へべれけ"
	CASE IS > (MAXBASE:ARG:酒気 / 10) * 5
		RETURNF "酔いどれ"
	CASE IS <= (MAXBASE:ARG:酒気 / 10) * 5
		RETURNF "ほろ酔い"
ENDSELECT
;-------------------------------------------------
;はい／いいえ の選択肢を表示し入力結果を返す関数
;引数 0=肯定選択肢の文字列、1=否定選択肢の文字列
;戻り値 0=はい、1=いいえ
;-------------------------------------------------
@ASK_YN(ARGS:0 = "は  い", ARGS:1 = "いいえ")
CURRENTREDRAW
LOCAL:0 = RESULT
REDRAW 0
PRINTBUTTON @" [%ARGS:0%]", 0
PRINTL
PRINTBUTTON @" [%ARGS:1%]", 1
PRINTL 
$INPUT_LOOP
INPUT
IF RESULT != 0 && RESULT != 1
	CLEARLINE 1
	CALL SIMATTYAUOJISAN
	GOTO INPUT_LOOP
ENDIF
REDRAW LOCAL:0
RETURN RESULT
;-------------------------------------------------
;特殊な機能を持つボタンを作成する関数
;ARGは入力される数字、ARG:1に1を設定すると灰色に、
;ARG:2に1を設定するとボタンが黄色、ARG:3に1を設定するとボタンが無効(灰色)
;-------------------------------------------------
@PRINTBUTTON_EX(ARGS:0, ARG,ARG:1,ARG:2,ARG:3)
IF ARG:3
	SETCOLOR C_L_GRAY
	PRINTFORM %ARGS:0%
ELSE
	SIF ARG:2
		SETCOLOR C_YELLOW
	SIF ARG:1
		SETCOLOR C_L_GRAY
	PRINTBUTTON @"%ARGS:0%", ARG
ENDIF
RESETCOLOR
;-------------------------------------------------
;特殊な機能を持つボタンを作成する関数
;ARGは入力される数字、ARG:1に1を設定すると灰色に、
;ARG:2に1を設定するとボタンが黄色、ARG:3に1を設定するとボタンが無効(灰色)
;-------------------------------------------------
@PRINTBUTTON_EXC(ARGS:0, ARG,ARG:1,ARG:2,ARG:3)
IF ARG:3
	SETCOLOR C_L_GRAY
	PRINTFORMC %ARGS:0%
ELSE
	SIF ARG:2
		SETCOLOR C_YELLOW
	SIF ARG:1
		SETCOLOR C_L_GRAY
	PRINTBUTTONC @"%ARGS:0%", ARG
ENDIF
RESETCOLOR
;-------------------------------------------------
;Fisher-Yatesアルゴリズムによるシャッフル配列の作成
;専用配列SHAFFLE_ARRAYを使用
;引数 0:配列の長さ（0～ARG:0-1までのシャッフル） 
;-------------------------------------------------
@FISHER_YATES_SHAFFLE(ARG:0)
;シャッフル配列の初期化
SIF !INRANGE(ARG:0 , 1 , 499)
	THROW 引数({ARG:0})が異常です。1～499の範囲で指定してください。
VARSET SHAFFLE_ARRAY , 0
;SHAFFLE_ARRAYの初期化
FOR LOCAL:0 , 0 , ARG:0
	SHAFFLE_ARRAY:(LOCAL:0) = LOCAL:0
NEXT

FOR LOCAL:0 , 0 , ARG:0 - 1
	LOCAL:1 = RAND(LOCAL:0 , ARG:0)
	SWAP SHAFFLE_ARRAY:(LOCAL:0), SHAFFLE_ARRAY:(LOCAL:1)
NEXT
;終端用に-1をセット
SHAFFLE_ARRAY:(ARG:0) = -1
RETURN 0

@NEMUKE()
#FUNCTION
LOCAL =  TIME + 1440 * DAY - TFLAG:主人公起床 - TFLAG:198
RETURNF LOCAL

;-------------------------------------------------
;時刻表示(ARG)
;与えられたTIMEをH時MM分表示に変換
;-------------------------------------------------
@時刻表示(ARG)
#FUNCTIONS
#DIM HOUR
#DIM MINUTE
#DIMS 時刻
HOUR   = ARG / 60
MINUTE = ARG % 60
時刻 = %TOSTR(HOUR)%時%TOSTR(MINUTE,"00")%分
RETURNF 時刻
;-------------------------------------------------
;TIMESTOP(ARG)
;そのキャラの時間停止状態を返す
;0=時間停止なし（意識あり）　1=時間停止世界入り（意識あり）　2=完全に止められてる（意識がない状態）
;-------------------------------------------------
@TIMESTOP(ARG)
#FUNCTION
;引数を略すとTARGET
SIF !ARG
	ARG = TARGET
IF !FLAG:70
	LOCAL = 0
ELSEIF CFLAG:ARG:344 == 1
	LOCAL = 1
ELSE
	LOCAL = 2
ENDIF
RETURNF LOCAL

@KIGEN_CHANGE(ARG,確率,傾向)
#DIM 確率
#DIM 傾向
;傾向を1にすると+のみ、-1にすると-のみ
SIF TALENT:ARG:感情缺乏
	確率 /= 2
IF RAND:100 < 確率
	IF !傾向
		IF !RAND:2
			TALENT:ARG:心情 ++
		ELSE
			TALENT:ARG:心情 --
		ENDIF
	ELSE
		TALENT:ARG:心情 += 傾向
	ENDIF
ENDIF
TALENT:ARG:心情 = LIMIT(TALENT:ARG:心情,-1,1)

;-------------------------------------------------
;ARGが討厭男人で主人公が男なら1
;ARGが討厭女人で主人公が女なら2を返す
;恋慕愛欲兩面通吃で無効
;-------------------------------------------------
@OTOKOGIRAI(ARG)
#FUNCTION
;兩面通吃
SIF TALENT:ARG:性別嗜好 == -1
	RETURNF 0
;恋慕
SIF TALENT:ARG:恋慕
	RETURNF 0
SIF TALENT:ARG:愛欲
	RETURNF 0
;討厭男人
IF TALENT:ARG:性別嗜好 & 1 && !(TALENT:PLAYER:2 & 1)
	RETURNF 1
;討厭女人
ELSEIF TALENT:ARG:性別嗜好 & 2 && !(TALENT:PLAYER:2 & 2)
	RETURNF 2
ENDIF
RETURNF 0



;-------------------------------------------------
;キャラチェックF関数
;-------------------------------------------------
;キャラクターが特定条件に合致しているかどうかを返す
;条件はTYPEごとに指定
;複合した条件に名前をつける時はキャラリストクラス関数を増設することにした
;-------------------------------------------------
@CHECK_CHARA(C_ID, TYPE = "存在")
#FUNCTION
#LOCALSIZE 1
#LOCALSSIZE 1
#DIMS DYNAMIC TYPE ;判定タイプ、DYNAMICしたので多重呼び出し可能
#DIM C_ID          ;登録番号
SELECTCASE TYPE
;基本条件
CASE "存在"
	RETURNF !CFLAG:C_ID:出禁
CASE "陥落"
	RETURNF (TALENT:C_ID:思慕 || TALENT:C_ID:恋慕 || TALENT:C_ID:愛欲 || TALENT:C_ID:恋人 || TALENT:C_ID:炮友)
CASE "弱み握り"
;C_IDがMASTERの弱みを握っている
	RETURNF CFLAG:C_ID:弱み握り
CASE "弱み握られ"
;C_IDがMASTERに弱みを握られている
	RETURNF CFLAG:C_ID:弱み握られ
CASE "反発刻印"
	RETURNF (MARK:C_ID:反発刻印 >= 1)
CASE "時姦刻印"
	RETURNF (MARK:C_ID:時姦刻印 >= 1)
CASE "時姦経験"
	RETURNF (EXP:C_ID:時姦経験 >= 1)
CASE "清い交際"
	RETURNF (CFLAG:C_ID:清い交際 >= 1)
CASE "同室"
	RETURNF (CFLAG:C_ID:現在位置 == CFLAG:MASTER:現在位置)
CASE "全裸"
	{
	SIF EQUIP:C_ID:飾品 || EQUIP:C_ID:帽子 || EQUIP:C_ID:靴 || EQUIP:C_ID:襪子
		 || EQUIP:C_ID:下半身内袴１ || EQUIP:C_ID:下半身内袴２
		 || EQUIP:C_ID:上半身内袴１ || EQUIP:C_ID:上半身内袴２
		 || EQUIP:C_ID:緊身内衣 || EQUIP:C_ID:連体内衣 || EQUIP:C_ID:連衣裙 || EQUIP:C_ID:和服
		 || EQUIP:C_ID:袴子 || EQUIP:C_ID:下半身上衣 || EQUIP:C_ID:裙子
		 || EQUIP:C_ID:上半身上衣１ || EQUIP:C_ID:上半身上衣２ || EQUIP:C_ID:外衣
		 || EQUIP:C_ID:其他１ || EQUIP:C_ID:其他２ || EQUIP:C_ID:其他３ || EQUIP:C_ID:腕部装束
	}
		RETURNF 0
	RETURNF 1
CASE "オンナ"
	RETURNF TALENT:C_ID:性別 == 1
CASE "Futanari"
	RETURNF TALENT:C_ID:性別 == 3
CASE "ケモミミ"
	RETURNF TALENT:C_ID:動物耳 != 0
CASE "人間耳"
	RETURNF TALENT:C_ID:動物耳 == 0
CASE "非処女"
	SIF TALENT:C_ID:性別 == 2
		RETURNF 0
	RETURNF GROUPMATCH(TALENT:C_ID:処女, 0, -1)
CASEELSE
	THROW 不明なTYPE%TYPE%
ENDSELECT



;-------------------------------------------------
;キャラ比較関数
;-------------------------------------------------
;全引数必須
;スマートとは程遠いコピペゴリ押しである
;-------------------------------------------------
@CHARA_COMPARE(VAR_NAME, VAR_ID, CHARA_A, TYPE, CHARA_B)
#FUNCTION
#DIMS VAR_NAME ;比較対象キャラ変数
#DIM  VAR_ID   ;比較対象キャラ変数のID
#DIM  CHARA_A  ;比較対象キャラAの登録番号
#DIMS TYPE     ;比較内容
#DIM  CHARA_B  ;比較対象キャラBの登録番号
SELECTCASE VAR_NAME
CASE "ABL"
	SELECTCASE TYPE
	CASE "=="
		RETURNF ABL:CHARA_A:VAR_ID == ABL:CHARA_B:VAR_ID
	CASE ">"
		RETURNF ABL:CHARA_A:VAR_ID > ABL:CHARA_B:VAR_ID
	CASE ">="
		RETURNF ABL:CHARA_A:VAR_ID >= ABL:CHARA_B:VAR_ID
	CASE "<"
		RETURNF ABL:CHARA_A:VAR_ID < ABL:CHARA_B:VAR_ID
	CASE "<="
		RETURNF ABL:CHARA_A:VAR_ID <= ABL:CHARA_B:VAR_ID
	CASEELSE
		THROW 不明なTYPE　%TYPE%
	ENDSELECT
	
CASE "BASE"
	SELECTCASE TYPE
	CASE "=="
		RETURNF BASE:CHARA_A:VAR_ID == BASE:CHARA_B:VAR_ID
	CASE ">"
		RETURNF BASE:CHARA_A:VAR_ID > BASE:CHARA_B:VAR_ID
	CASE ">="
		RETURNF BASE:CHARA_A:VAR_ID >= BASE:CHARA_B:VAR_ID
	CASE "<"
		RETURNF BASE:CHARA_A:VAR_ID < BASE:CHARA_B:VAR_ID
	CASE "<="
		RETURNF BASE:CHARA_A:VAR_ID <= BASE:CHARA_B:VAR_ID
	CASEELSE
		THROW 不明なTYPE　%TYPE%
	ENDSELECT
	
CASE "MAXBASE"
	SELECTCASE TYPE
	CASE "=="
		RETURNF MAXBASE:CHARA_A:VAR_ID == MAXBASE:CHARA_B:VAR_ID
	CASE ">"
		RETURNF MAXBASE:CHARA_A:VAR_ID > MAXBASE:CHARA_B:VAR_ID
	CASE ">="
		RETURNF MAXBASE:CHARA_A:VAR_ID >= MAXBASE:CHARA_B:VAR_ID
	CASE "<"
		RETURNF MAXBASE:CHARA_A:VAR_ID < MAXBASE:CHARA_B:VAR_ID
	CASE "<="
		RETURNF MAXBASE:CHARA_A:VAR_ID <= MAXBASE:CHARA_B:VAR_ID
	CASEELSE
		THROW 不明なTYPE　%TYPE%
	ENDSELECT
	
CASE "EXP"
	SELECTCASE TYPE
	CASE "=="
		RETURNF EXP:CHARA_A:VAR_ID == EXP:CHARA_B:VAR_ID
	CASE ">"
		RETURNF EXP:CHARA_A:VAR_ID > EXP:CHARA_B:VAR_ID
	CASE ">="
		RETURNF EXP:CHARA_A:VAR_ID >= EXP:CHARA_B:VAR_ID
	CASE "<"
		RETURNF EXP:CHARA_A:VAR_ID < EXP:CHARA_B:VAR_ID
	CASE "<="
		RETURNF EXP:CHARA_A:VAR_ID <= EXP:CHARA_B:VAR_ID
	CASEELSE
		THROW 不明なTYPE　%TYPE%
	ENDSELECT
	
CASE "CFLAG"
	SELECTCASE TYPE
	CASE "=="
		RETURNF CFLAG:CHARA_A:VAR_ID == CFLAG:CHARA_B:VAR_ID
	CASE ">"
		RETURNF CFLAG:CHARA_A:VAR_ID > CFLAG:CHARA_B:VAR_ID
	CASE ">="
		RETURNF CFLAG:CHARA_A:VAR_ID >= CFLAG:CHARA_B:VAR_ID
	CASE "<"
		RETURNF CFLAG:CHARA_A:VAR_ID < CFLAG:CHARA_B:VAR_ID
	CASE "<="
		RETURNF CFLAG:CHARA_A:VAR_ID <= CFLAG:CHARA_B:VAR_ID
	CASEELSE
		THROW 不明なTYPE　%TYPE%
	ENDSELECT
	
CASE "PALAM"
	SELECTCASE TYPE
	CASE "=="
		RETURNF PALAM:CHARA_A:VAR_ID == PALAM:CHARA_B:VAR_ID
	CASE ">"
		RETURNF PALAM:CHARA_A:VAR_ID > PALAM:CHARA_B:VAR_ID
	CASE ">="
		RETURNF PALAM:CHARA_A:VAR_ID >= PALAM:CHARA_B:VAR_ID
	CASE "<"
		RETURNF PALAM:CHARA_A:VAR_ID < PALAM:CHARA_B:VAR_ID
	CASE "<="
		RETURNF PALAM:CHARA_A:VAR_ID <= PALAM:CHARA_B:VAR_ID
	CASEELSE
		THROW 不明なTYPE　%TYPE%
	ENDSELECT
	
CASE "TALENT"
	SELECTCASE TYPE
	CASE "=="
		RETURNF TALENT:CHARA_A:VAR_ID == TALENT:CHARA_B:VAR_ID
	CASE ">"
		RETURNF TALENT:CHARA_A:VAR_ID > TALENT:CHARA_B:VAR_ID
	CASE ">="
		RETURNF TALENT:CHARA_A:VAR_ID >= TALENT:CHARA_B:VAR_ID
	CASE "<"
		RETURNF TALENT:CHARA_A:VAR_ID < TALENT:CHARA_B:VAR_ID
	CASE "<="
		RETURNF TALENT:CHARA_A:VAR_ID <= TALENT:CHARA_B:VAR_ID
	CASEELSE
		THROW 不明なTYPE　%TYPE%
	ENDSELECT
	
CASE "TCVAR"
	SELECTCASE TYPE
	CASE "=="
		RETURNF TCVAR:CHARA_A:VAR_ID == TCVAR:CHARA_B:VAR_ID
	CASE ">"
		RETURNF TCVAR:CHARA_A:VAR_ID > TCVAR:CHARA_B:VAR_ID
	CASE ">="
		RETURNF TCVAR:CHARA_A:VAR_ID >= TCVAR:CHARA_B:VAR_ID
	CASE "<"
		RETURNF TCVAR:CHARA_A:VAR_ID < TCVAR:CHARA_B:VAR_ID
	CASE "<="
		RETURNF TCVAR:CHARA_A:VAR_ID <= TCVAR:CHARA_B:VAR_ID
	CASEELSE
		THROW 不明なTYPE　%TYPE%
	ENDSELECT
	
CASE "MARK"
	SELECTCASE TYPE
	CASE "=="
		RETURNF MARK:CHARA_A:VAR_ID == MARK:CHARA_B:VAR_ID
	CASE ">"
		RETURNF MARK:CHARA_A:VAR_ID > MARK:CHARA_B:VAR_ID
	CASE ">="
		RETURNF MARK:CHARA_A:VAR_ID >= MARK:CHARA_B:VAR_ID
	CASE "<"
		RETURNF MARK:CHARA_A:VAR_ID < MARK:CHARA_B:VAR_ID
	CASE "<="
		RETURNF MARK:CHARA_A:VAR_ID <= MARK:CHARA_B:VAR_ID
	CASEELSE
		THROW 不明なTYPE　%TYPE%
	ENDSELECT
	
CASEELSE
	THROW 不明なVAR_NAME　%VAR_NAME%
ENDSELECT

[SKIPSTART]
コレをコピペして置換すれば項目をふやせる
CASE "CVAR"
	SELECTCASE TYPE
	CASE "=="
		RETURNF CVAR:CHARA_A:VAR_ID == CVAR:CHARA_B:VAR_ID
	CASE ">"
		RETURNF CVAR:CHARA_A:VAR_ID > CVAR:CHARA_B:VAR_ID
	CASE ">="
		RETURNF CVAR:CHARA_A:VAR_ID >= CVAR:CHARA_B:VAR_ID
	CASE "<"
		RETURNF CVAR:CHARA_A:VAR_ID < CVAR:CHARA_B:VAR_ID
	CASE "<="
		RETURNF CVAR:CHARA_A:VAR_ID <= CVAR:CHARA_B:VAR_ID
	CASEELSE
		THROW 不明なTYPE　%TYPE%
	ENDSELECT
[SKIPEND]



;-------------------------------------------------
;ステータス評価表示関数
;-------------------------------------------------
;元は@PRINT_アルファベット評価
;引数を評価対象数値にすることで汎用化し
;RANK_SCALEの名称をわかりやすくした
;-------------------------------------------------
@PRINT_RANK(VAR_VALUE, RANK_SCALE)
#DIM  VAR_VALUE  ;評価対象数値
#DIMS RANK_SCALE ;評価に使用する尺度の種類
#DIM  RANK       ;評価ランク、数が小さいほど優秀
#DIM  RANK_NUM   ;評価尺度に含まれる評価の種数
CALL CALC_RANK(VAR_VALUE, RANK_SCALE, RANK, RANK_NUM)
CALL PRINT_ALPHABET(RANK, RANK_NUM)



;-------------------------------------------------
;ステータス評価算出関数
;-------------------------------------------------
;RANK_SCALEにもとづいてVAR_VALUEの評価を行う
;REFによりRANK/RANK_NUMとして渡された引数の数値を直接書き換える
;-------------------------------------------------
@CALC_RANK(VAR_VALUE, RANK_SCALE, RANK, RANK_NUM)
#DIM      VAR_VALUE  ;評価対象数値
#DIMS     RANK_SCALE ;評価に使用する尺度の種類
#DIM  REF RANK       ;評価ランク、数が小さいほど優秀
#DIM  REF RANK_NUM   ;評価尺度に含まれる評価の種数
SELECTCASE RANK_SCALE
CASE "MAX_50000"
;好感度用
	RANK_NUM = 10
	SELECTCASE VAR_VALUE
	CASE IS >= 50000
		RANK = 0
	CASE IS >= 30000
		RANK = 1
	CASE IS >= 10000
		RANK = 2
	CASE IS >=  5000
		RANK = 3
	CASE IS >=  3000
		RANK = 4
	CASE IS >=  1500
		RANK = 5
	CASE IS >=  1000
		RANK = 6
	CASE IS >=   500
		RANK = 7
	CASE IS >=   100
		RANK = 8
	CASEELSE
		RANK = 9
	ENDSELECT
CASE "MAX_20000"
;信頼度用
	RANK_NUM = 10
	SELECTCASE VAR_VALUE
	CASE IS >= 20000
		RANK = 0
	CASE IS >= 10000
		RANK = 1
	CASE IS >=  3000
		RANK = 2
	CASE IS >=  1000
		RANK = 3
	CASE IS >=   500
		RANK = 4
	CASE IS >=   150
		RANK = 5
	CASE IS >=   100
		RANK = 6
	CASE IS >=    50
		RANK = 7
	CASE IS >=    10
		RANK = 8
	CASEELSE
		RANK = 9
	ENDSELECT
CASE "MAX_99"
;技術系以外のABL
	;数字が縦に並ぶと非常に見にくかったんで意図的にインデントずらしてます
	RANK_NUM = 10
	SELECTCASE VAR_VALUE
	CASE IS >= 99
			RANK = 0
	CASE IS >= 75
			RANK = 1
	CASE IS >= 50
			RANK = 2
	CASE IS >= 20
			RANK = 3
	CASE IS >= 10
			RANK = 4
	CASE IS >=  5
			RANK = 5
	CASE IS >=  3
			RANK = 6
	CASE IS >=  2
			RANK = 7
	CASE IS >=  1
			RANK = 8
	CASEELSE
			RANK = 9
	ENDSELECT
CASE "MAX_6"
;技能系ABL
	RANK_NUM = 7
	SELECTCASE VAR_VALUE
	CASE IS >= 6
			RANK = 0
	CASE IS >= 5
			RANK = 1
	CASE IS >= 4
			RANK = 2
	CASE IS >= 3
			RANK = 3
	CASE IS >= 2
			RANK = 4
	CASE IS >= 1
			RANK = 5
	CASEELSE
			RANK = 6
	ENDSELECT
CASEELSE
	THROW 不明なRANK_SCALE %RANK_SCALE%
ENDSELECT



;-------------------------------------------------
;ランク評価表示関数
;-------------------------------------------------
;ランク評価(数字が小さいほど優秀)の内容をアルファベット表記してカラー表示する
;形式さえあってりゃ別にPRINT_RANKでなくとも使えるぞ
;-------------------------------------------------
@PRINT_ALPHABET(RANK, RANK_NUM)
#DIM RANK
#DIM RANK_NUM
#DIMS CONST STR_RANK10, 10 = "Ex", "SS", " S", " A", " B", " C", " D", " E", " F", " G"
#DIMS CONST STR_RANK7,   7 = "Ex", " S", " A", " B", " C", " D", " E"
{
#DIMS  CONST C_RANK10, 10 = 
	"C_P_PURPLE", "C_WHITE", "C_WHITE", "C_PINK", "C_RED", 
	"C_ORANGE", "C_YELLOW", "C_GREEN", "C_AQUA", "C_GRAY"
}
#DIMS  CONST C_RANK7,   7 = "C_P_PURPLE", "C_WHITE", "C_PINK", "C_RED", "C_ORANGE", "C_YELLOW", "C_GRAY"
SELECTCASE RANK_NUM
CASE 10
	CALL COLOR_PRINT(STR_RANK10:RANK, C_RANK10:RANK, 2)
CASE  7
	CALL COLOR_PRINT(STR_RANK7:RANK, C_RANK7:RANK, 2)
CASEELSE
	THROW 不正なRANK_NUM {RANK_NUM}
ENDSELECT
RESETCOLOR



;-------------------------------------------------
;色付きPRINT関数
;-------------------------------------------------
;渡した文字を渡した色でPRINTしてRESETCOLOR
;広域変数でDIMってある色名のみ可能（追加は容易）
;-------------------------------------------------
@COLOR_PRINT(ARGS, C_NAME, STR_NUM = 2)
#DIMS C_NAME
#DIM  STR_NUM
SIF !STRLENS(ARGS)
	RETURN
SELECTCASE C_NAME
CASE "C_P_PURPLE"
	SETCOLOR C_P_PURPLE
CASE "C_WHITE"
	SETCOLOR C_WHITE
CASE "C_PINK"
	SETCOLOR C_PINK
CASE "C_RED"
	SETCOLOR C_RED
CASE "C_ORANGE"
	SETCOLOR C_ORANGE
CASE "C_YELLOW"
	SETCOLOR C_YELLOW
CASE "C_GREEN"
	SETCOLOR C_GREEN
CASE "C_AQUA"
	SETCOLOR C_AQUA
CASE "C_GRAY"
	SETCOLOR C_GRAY
CASEELSE
	THROW 不正なC_NAME %C_NAME%
ENDSELECT
PRINTFORM %ARGS, STR_NUM%
RESETCOLOR



;-------------------------------------------------
;BASEカラーバー関数
;-------------------------------------------------
;体力などのカラーバー
;-------------------------------------------------
@BASE_BAR(C_ID, BASE_NAME, BAR_LENGTH, COLOR_NAME, OP)
#DIM  C_ID
#DIMS BASE_NAME
#DIM  BAR_LENGTH
#DIMS COLOR_NAME
#DIMS OP
#DIM  BASE_ID
BASE_ID = FINDELEMENT(BASENAME, BASE_NAME)
SIF BASE_ID < 0
	THROW 存在しないBASE_NAME %BASE_NAME%
SIF !STRCOUNT(OP, "「種類表記無し」")
	PRINTFORM %BASE_NAME, 4% 
CALL PRINT_COLORBAR(BASE:C_ID:BASE_ID, MAXBASE:C_ID:BASE_ID, BAR_LENGTH, UNICODE(0x2585), UNICODE(0x2585), BARCOLORSET(COLOR_NAME), RESULT:1)
IF !STRCOUNT(OP, "「数字表記無し」")
	IF BUFF:C_ID:BASE_ID > 0
		SETCOLOR C_AQUA
	ELSEIF BUFF:C_ID:BASE_ID < 0
		SETCOLOR C_YELLOW
	ENDIF
	PRINTFORM  ({BASE:C_ID:BASE_ID,5}/{MAXBASE:C_ID:BASE_ID,5}) 
	RESETCOLOR
ENDIF
SIF STRCOUNT(OP, "「改行」")
	PRINTFORML 


;-------------------------------------------------
;カラースタンプ関数
;-------------------------------------------------
;特定の記号を特定の色で並べる
;MARKの表示用だけどなんか其他にも使えるでしょう
;-------------------------------------------------
@COLOR_STAMP(STAMP_NUM, MAX_NUM, STAMP_STR, STAMP_COLOR)
#DIM  STAMP_NUM   ;並べるスタンプの数
#DIM  MAX_NUM     ;スタンプの最大数
#DIMS STAMP_STR   ;スタンプに使用する文字列
#DIM  STAMP_COLOR ;スタンプの色
#DIM  STAMP_LENGTH;スタンプ文字列の長さ
STAMP_LENGTH = STRLENS(STAMP_STR)
SIF !STAMP_LENGTH
	THROW STAMP_STRが指定されていません
SIF STAMP_COLOR
	SETCOLOR STAMP_COLOR
PRINTFORM %" " * (MAX_NUM - STAMP_NUM) * STAMP_LENGTH%
PRINTFORM %STAMP_STR * STAMP_NUM%
RESETCOLOR

;-------------------------------------------------
;キャラ抽選関数
;-------------------------------------------------
;キャラリストからランダムで1名を選出する
;戻り値は登録番号、失敗したら-1
;-------------------------------------------------
@RAND_CHARASELECT(L_TYPE = "主人公以外のキャラリスト")
#DIMS L_TYPE                       ;抽選対象タイプ
#DIM  L_ID                         ;リストのクラスID
#DIM  CHARA_LIST, キャラクタ数上限 ;作成するリスト
#DIM  CHARA_CNT                    ;キャラカウンタ
CALL MAKE_CHARA_LIST("主人公以外のキャラリスト", L_ID, CHARA_LIST, CHARA_CNT)
SIF !CHARA_CNT
	RETURN -1
RETURN CHARA_LIST:(RAND:CHARA_CNT)



;----------------------------------------------------------------------------------------------------
;キャラの登場判定
;とりあえず主人公は弾くようにした
;----------------------------------------------------------------------------------------------------
@CAN_MEET(CHARA)
#FUNCTION
#DIM CHARA
SIF !CHARA
	RETURNF 0
SIF !EXISTCSV(CHARA)
	RETURNF 0
SIF CFLAG:CHARA:出禁
	RETURNF 0
SIF CHARA == FLAG:なりきり
	RETURNF 0
RETURNF 1

;----------------------------------------------------------------------------------------------------
;現在地点から移動可能な場所へ移動
;部屋から追い出されるときなど
;----------------------------------------------------------------------------------------------------
@GETOUT(ARG)
FOR LOCAL,MINROOM(),MAXROOM
	IF CAN_MOVE(CFLAG:ARG:現在位置, LOCAL) & 1
		CFLAG:ARG:現在位置 = LOCAL
		BREAK
	ENDIF
NEXT

;----------------------------------------------------------------------------------------------------
;キャラのランダム選抜関数
;手抜き処理でできるだけ簡素な抽選関数をと思った（RAND_CHARASELECTはちと凝り過ぎ）
;渡したキャラは選ばれない
;出禁キャラが多すぎると無限ループのおそれがあるのが難点
;難点とはいうが全キャラ対象の抽選では
;極端なプレイングをしなければ問題にはならない、はず
;----------------------------------------------------------------------------------------------------
@RAND_PERSON(CHARA)
#FUNCTION
#DIM CHARA
#DIM HIT_CHARA
DO
	HIT_CHARA = RAND(1, キャラクタ数上限)
	SIF !CAN_MEET(HIT_CHARA) || HIT_CHARA == CHARA
		CONTINUE
	BREAK
LOOP 1
RETURNF HIT_CHARA



;----------------------------------------------------------------------------------------------------
;自宅位置取得関数
;----------------------------------------------------------------------------------------------------
@GET_CHARAHOME(CHARA)
#FUNCTION
#DIM CHARA
SIF !MAIN_MAP && CFLAG:CHARA:神社在住
	RETURNF CFLAG:CHARA:神社在住
;GET_MAPID対策
SIF GROUPMATCH(CSVCFLAG(CHARA, GETNUM(CFLAG, "初期位置")), 0, 99)
	RETURNF -100
RETURNF CSVCFLAG(CHARA, GETNUM(CFLAG, "初期位置"))


;----------------------------------------------------------------------------------------------------
;場所名取得関数
;MAIN_MAP次第で挙動が変わってしまって個人的に気持ち悪い
;問題点：GET_MAP_REPLACEMENTを使用済みのPLACE_IDを受け取ると誤動作≒散策マップの場所IDは受け取れません
;----------------------------------------------------------------------------------------------------
@GET_PLACENAME(PLACE_ID)
#FUNCTIONS
#DIM PLACE_ID
SIF PLACE_ID == SUKIMA()
	RETURNF "隙間空間"
SIF PLACE_ID == OMANEKIBEYA()
	RETURNF OMANEKI_PLACE()
IF GET_MAPID(PLACE_ID) == MAIN_MAP
	RETURNF NAME_FROM_PLACE(PLACE_ID)
ELSE
	RETURNF STR:(6000 + GET_MAP_REPLACEMENT(PLACE_ID) / 10)
ENDIF


;----------------------------------------------------------------------------------------------------
;配列抽選F関数
;----------------------------------------------------------------------------------------------------
@ARRAY_HIT(HIT_LIST, LIST_SIZE)
#FUNCTION
#DIM REF HIT_LIST ;確率分布リスト
#DIM     LIST_SIZE;確率分布リストのサイズ
#DIM     CHK_ID   ;判定対象となる要素
#DIM     HIT_RAND ;抽選乱数処理
HIT_RAND = RAND(0, SUMARRAY(HIT_LIST, 0, LIST_SIZE))
;DEBUGPRINTFORML LIST_SIZE＝{LIST_SIZE}　HIT_RAND{HIT_RAND}
FOR CHK_ID, 0, LIST_SIZE
	SIF HIT_RAND < SUMARRAY(HIT_LIST, 0, CHK_ID + 1)
		RETURNF CHK_ID
NEXT
THROW 抽選失敗


;----------------------------------------------------------------------------------------------------
;配列RAND化関数
;重複制限なしなので適宜FISHER_YATES_SHAFFLEと使い分けて下さい
;----------------------------------------------------------------------------------------------------
@ARRAY_RAND(RAND_ARRAY, ARRAY_SIZE, RAND_MIN, RAND_MAX)
#DIM REF RAND_ARRAY; 対象配列
#DIM     ARRAY_SIZE; 配列サイズ（1以上）
#DIM     RAND_MIN  ; RANDの下限（0以上）
#DIM     RAND_MAX  ; RANDの上限-1、この数自体は抽選に選ばれない（RAND_MIN+1以上）
#DIM     ID_ARRAY  ; ループ用
FOR ID_ARRAY, 0, ARRAY_SIZE
	RAND_ARRAY:ID_ARRAY = RAND(RAND_MIN, RAND_MAX)
NEXT


;----------------------------------------------------------------------------------------------------
;FISHER_YATES_SHAFFLE（F関数版）
;ソースはwikipedia
;CALLF FUNC_FISHER_YATES_SHAFFLE(LOCAL, 10)
;これでLOCAL:0～9に0～9が重複なしで代入される
;----------------------------------------------------------------------------------------------------
@FUNC_FISHER_YATES_SHAFFLE(ARRAY, ARRAY_SIZE)
#FUNCTION
#DIM REF ARRAY   ;対象配列
#DIM ARRAY_SIZE  ;配列の長さ（2以上の数値にして下さい）
#DIM ELE_SHAFFLE ;シャッフル対象要素
VARSET ARRAY, -1
ARRAY:0 = 0
;要素0に対する↓の処理は必ず0になるんだから1以降でおｋ
FOR LOCAL:0, 1, ARRAY_SIZE
	ELE_SHAFFLE = RAND(0, LOCAL:0 + 1)
	;挙動変わらないようならif設けるより素通しの方が処理数少なくなったりせんか？
	;SIF ELE_SHAFFLE != LOCAL:0
	ARRAY:(LOCAL:0) = ARRAY:ELE_SHAFFLE
	ARRAY:ELE_SHAFFLE = LOCAL:0
NEXT


;----------------------------------------------------------------------------------------------------
;複数行自動表示関数
;一種の超簡易アニメーション
;1秒に1行追記していくよ関数だよ
;渡された配列の要素を順番に表示する
;本格的に動かしたいならぱにめーしょん使え
;使用箇所は納茲琳のダウジングコマンド
;----------------------------------------------------------------------------------------------------
@PRINT_GROUP(COMMENT, NUM_COMMENT, TIME_REDRAW = 1000)
#DIMS REF COMMENT         ;表示する文字列の配列
#DIM  NUM_COMMENT         ;配列の要素数
#DIM  PREV_REDRAW         ;一時退避用
#DIM  TIME_REDRAW         ;行追加の間隔、標準で1秒
#DIM  DYNAMIC NOW_COMMENT ;表示隠蔽制御用
PREV_REDRAW = CURRENTREDRAW()
REDRAW 0
FOR LOCAL:0, 0, NUM_COMMENT
	FOR LOCAL:1, 0, NUM_COMMENT
		IF LOCAL:1 <= NOW_COMMENT
			PRINTFORML %COMMENT:(LOCAL:1)%
		ELSE
			PRINTFORML 
		ENDIF
	NEXT
	TWAIT TIME_REDRAW, 0
	NOW_COMMENT ++ 
	SIF LOCAL:0 < NUM_COMMENT -1
		CLEARLINE NUM_COMMENT
NEXT
REDRAW PREV_REDRAW
WAIT
