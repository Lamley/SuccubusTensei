[SKIPSTART]
・F関数系にTRYCALLがねぇのがキツイっす（存在しなくてもエラー吐かないようにはならんもんか？）
→存否を事前に変数として保持して存在しないなら先にそこで弾く、これでおｋ
・F関数系は一つの関数につき戻り値がSTRもしくはINTに限定されてめんどくさい
→@TEMP_STOCKを経由したやりくりで解決
→FUNCTIONSならSTR型でTOSTR(INT)を返せる、INT変数を用意しておけば保持自体は余裕
・整数型・文字列型変数を組み合わせて参照したい
→ぜんぶ引数のかたちで渡してやればいい
・関数間での変数の柔軟な受け渡し（一文字変数地獄はイヤ）
→CALLFの活用によって擬似的に変数を定義してやれば関数をまたいだ変数のやりとりが可能
→変数名を毎回自前で定義できるから一文字変数と違って上書きの心配がないよ！

欠点
・変数管理の手間が煩雑になる
・メモリリークのおそれがある
・変数をスタックさせすぎるとエラー
・変数名による誤消去のおそれ

・とりあえずGET_INT/GET_STRして使う分にはあまり気にしなくていい

2017/02/22
・デバッグ文を仕込みすぎてデバッグモードがクソ重かったのでコメントアウト

[SKIPEND]

;デバッグ用、一時変数の列挙
;例のREF変数の有効活用例
@TEST_TEMPLIST(VAR_NAME, VAR_STR, VAR_INT, VAR_CNT)
#FUNCTIONS
#DIMS REF VAR_NAME ;変数名の保持
#DIMS REF VAR_STR  ;変数情報（STR）の保持
#DIM  REF VAR_INT  ;変数情報（INT）の保持
#DIM  REF VAR_CNT  ;変数の保持数
#DIM  VAR_ID
DEBUGPRINTFORM TEMPLIST VAR_NAME：%VAR_NAME:VAR_CNT%　
DEBUGPRINTFORML VAR_CNT：{VAR_CNT}
DEBUGPRINTFORM 　
FOR VAR_ID, 1, VAR_TEMP_MAX + 1
	SIF !STRLENS(VAR_NAME:VAR_ID)
		BREAK
	DEBUGPRINTFORM VAR_ID：{VAR_ID}　
	DEBUGPRINTFORM VAR_NAME：%VAR_NAME:VAR_ID%　
	DEBUGPRINTFORM VAR_STR：%VAR_STR:VAR_ID%　
	DEBUGPRINTFORM VAR_INT：%VAR_STR:VAR_ID%
NEXT
DEBUGPRINTFORML

;-----------------------------------------------
;ここから本体
;-----------------------------------------------
;一時変数保持関数本体
;この関数は直接呼ばない、参照や操作は後述の関数を介して行うこと
;-----------------------------------------------
;変数の保持関数
;とりあえず1～99までの99個を使用可能
;0を使ってないのはID0を返した時の挙動がややこしくなるため
;やたらTHROWが多いのは念のため
@TEMP_STOCK(COMMAND, ARGS:0, ARGS:1, ARG:0, ARG:1)
#FUNCTIONS
#DIMS COMMAND                       ;変数に対する実行コマンド
#DIMS VAR_NAME,  (VAR_TEMP_MAX + 1) ;変数名の保持
#DIMS VAR_STR,   (VAR_TEMP_MAX + 1) ;変数情報（STR）の保持
#DIM  VAR_INT,   (VAR_TEMP_MAX + 1) ;変数情報（INT）の保持
#DIM  VAR_CNT                       ;変数の保持数
#DIM LCOUNT
#DIM TEMP_ID
#DIM TEMP_CNT
;DEBUGPRINTFORML TEMP_STOCK_%COMMAND%, %ARGS:0%, %ARGS:1%, {ARG:0}, {ARG:1}

SELECTCASE COMMAND
;各種の取得コマンド、返り値に意味がある
;保持している変数の総数を返す
CASE "GET_TOTAL"
	;DEBUGPRINTFORML TEMP_STOCK VAR_CNT：{VAR_CNT}
	RETURNF TOSTR(VAR_CNT)

;変数名から内容を参照
CASE "GET_VALUE_BY_NAME"
	SIF !STRLENS(ARGS:0)
		THROW 変数名を設定して下さい
	TEMP_ID = FINDELEMENT(VAR_NAME, ARGS:0, 1, , 1)
	SIF TEMP_ID <= 0
		THROW 存在しない変数を参照しました%ARGS:0%
	IF STRLENS(VAR_STR:TEMP_ID)
		;DEBUGPRINTFORML TEMP_STOCK VAR_STR:TEMP_ID：%VAR_STR:TEMP_ID%
		RETURNF VAR_STR:TEMP_ID
	ELSE
		;DEBUGPRINTFORML TEMP_STOCK VAR_INT:TEMP_ID：{VAR_INT:TEMP_ID}
		RETURNF TOSTR(VAR_INT:TEMP_ID)
	ENDIF

;IDから内容を参照
CASE "GET_VALUE_BY_ID"
	SIF !ARG:0
		THROW IDを設定して下さい
	SIF !INRANGE(ARG:0, 1, VAR_CNT)
		THROW 存在しない変数を参照しました{ARG:0}
	IF STRLENS(VAR_STR:TEMP_ID)
		;DEBUGPRINTFORML TEMP_STOCK VAR_STR:TEMP_ID：%VAR_STR:TEMP_ID%
		RETURNF VAR_STR:TEMP_ID
	ELSE
		;DEBUGPRINTFORML TEMP_STOCK VAR_INT:TEMP_ID：{VAR_INT:TEMP_ID}
		RETURNF TOSTR(VAR_INT:TEMP_ID)
	ENDIF

;変数名から変数のIDを返す
;存在しない時は0
CASE "GET_ID"
	SIF !STRLENS(ARGS:0)
		THROW 変数名を設定して下さい
	TEMP_ID = FINDELEMENT(VAR_NAME, ARGS:0, 1, , 1)
	SIF TEMP_ID <= 0
		TEMP_ID = 0
	;DEBUGPRINTFORML TEMP_STOCK TEMP_ID：{TEMP_ID}
	RETURNF TOSTR(TEMP_ID)


;ARGS:0の含まれる変数名の数を返す
CASE "GET_CNT_NAME"
	TEMP_CNT = 0
	FOR TEMP_ID, 1, VAR_CNT + 1
		SIF STRCOUNT(VAR_NAME:TEMP_ID, ARGS:0)
			TEMP_CNT ++
	NEXT
	;DEBUGPRINTFORML TEMP_STOCK TEMP_CNT：{TEMP_CNT}
	RETURNF TOSTR(TEMP_CNT)

;変数の位置から変数名を返す
;存在しない時は空の文字列を返す
CASE "GET_NAME"
	TEMP_ID = ARG:0
	SIF !INRANGE(ARG:0, 1, VAR_TEMP_MAX)
		TEMP_ID = 0
	;DEBUGPRINTFORML TEMP_STOCK TEMP_ID：{TEMP_ID}
	RETURNF VAR_NAME:TEMP_ID

;ここから命令系、CALLFで各関数を介して使用のこと
;変数の作成
CASE "VARMAKE"
	SIF !STRLENS(ARGS:0)
		THROW 変数名を設定して下さい
	SIF VAR_CNT >= VAR_TEMP_MAX
		THROW 保持変数が上限に達しているため新たな変数を定義できません
	SIF ISNUMERIC(ARGS:0)
		THROW 数字のみからなる文字列を変数名に設定することは出来ません%ARGS:0%
	SIF FINDELEMENT(VAR_NAME, ARGS:0, 1, , 1) > 0
		THROW その変数名はすでに存在します%ARGS:0%
	VAR_CNT ++ 
	VAR_NAME:VAR_CNT = %ARGS:0%
	VAR_INT:VAR_CNT  = ARG:0
	VAR_STR:VAR_CNT  = %ARGS:1%
	;#; CALLF TEST_TEMPLIST(VAR_NAME, VAR_STR, VAR_INT, VAR_CNT)

;代入処理
;IDで変数を指定して代入
CASE "VARSET_BY_ID"
	SIF !INRANGE(ARG:0, 1, VAR_CNT)
		THROW 存在しない変数を参照しました{ARG:0}
	VAR_INT:TEMP_ID  = ARG:1
	VAR_STR:TEMP_ID  = %ARGS:0%
;名前で変数を指定して代入
CASE "VARSET_BY_NAME"
	SIF !STRLENS(ARGS:0)
		THROW 変数名を設定して下さい
	TEMP_ID = FINDELEMENT(VAR_NAME, ARGS:0, 1, , 1)
	SIF !INRANGE(TEMP_ID, 1, VAR_CNT)
		THROW 存在しない変数を参照しました%ARGS:0%
	VAR_INT:TEMP_ID  = ARG:0
	VAR_STR:TEMP_ID  = %ARGS:1%

;一つの変数を初期化
;ARGSが数値の場合にはINDEXと解釈する
;それ以外なら一致する変数名の位置を検索する
;存在しない時はエラー

;ID指定で変数を除去
CASE "VARCLEAR_BY_ID"
	SIF !INRANGE(ARG:0, 1, VAR_CNT)
		THROW 存在しない変数を参照しました{ARG:0}
	;CALLF TEST_TEMPLIST(VAR_NAME, VAR_STR, VAR_INT, VAR_CNT)
	ARRAYREMOVE VAR_NAME, ARG:0, 1
	ARRAYREMOVE VAR_INT , ARG:0, 1
	ARRAYREMOVE VAR_STR , ARG:0, 1
	VAR_CNT --
	;#; CALLF TEST_TEMPLIST(VAR_NAME, VAR_STR, VAR_INT, VAR_CNT)
;変数名指定で変数を除去
CASE "VARCLEAR_BY_NAME"
	TEMP_ID = FINDELEMENT(VAR_NAME, ARGS:0, 1, , 1)
	SIF TEMP_ID <= 0
		THROW 存在しない変数を参照しました%ARGS:0%
	;CALLF TEST_TEMPLIST(VAR_NAME, VAR_STR, VAR_INT, VAR_CNT)
	ARRAYREMOVE VAR_NAME, TEMP_ID, 1
	ARRAYREMOVE VAR_INT , TEMP_ID, 1
	ARRAYREMOVE VAR_STR , TEMP_ID, 1
	VAR_CNT --
	;CALLF TEST_TEMPLIST(VAR_NAME, VAR_STR, VAR_INT, VAR_CNT)
;変数名を部分一致検索して初期化
;巻き添え注意
CASE "VARCLEAR_BY_KEYWORD"
	SIF !STRLENS(ARGS:0)
		THROW 検索語句を設定して下さい
	TEMP_ID = FINDELEMENT(VAR_NAME, ARGS:0, 1, , 0)
	WHILE LOCAL > 0
		ARRAYREMOVE VAR_NAME, TEMP_ID, 1
		ARRAYREMOVE VAR_INT , TEMP_ID, 1
		ARRAYREMOVE VAR_STR , TEMP_ID, 1
		VAR_CNT --
		SIF !VAR_CNT
			BREAK
		TEMP_ID = FINDELEMENT(VAR_NAME, ARGS:0, 1, , 0)
	WEND
;変数を全て初期化
CASE "ALLCLEAR"
	VARSET VAR_NAME
	VARSET VAR_INT
	VARSET VAR_STR
	VARSET VAR_CNT
;算術系は変数の位置の判定が共通なのでまとめて先に
;ARGSが数値の場合にはINDEXと解釈する
;それ以外なら一致する変数名の位置を検索する
CASE "ADD_BY_ID", "TIMES_BY_ID", "PERCENT_BY_ID", "PPM_BY_ID",
	SIF !INRANGE(ARG:0, 1, VAR_CNT)
		THROW 存在しない変数を参照しました{ARG:0}
	
	SELECTCASE COMMAND
	;加算、もちろん負数も可能
	CASE "ADD_BY_ID"
		VAR_INT:(ARG:0) += ARG:1
	;乗算、小数値は渡せないので注意
	CASE "TIMES_BY_ID"
		VAR_INT:(ARG:0) *= ARG:1
	;指定変数をARGパーセントにする
	CASE "PERCENT_BY_ID"
		VAR_INT:(ARG:0) *= ARG:1
		VAR_INT:(ARG:0) /= 100
	;PPM＝百万分率
	CASE "PPM_BY_ID"
		VAR_INT:(ARG:0) *= ARG:1
		VAR_INT:(ARG:0) /= 1000000
	CASEELSE
		THROW 未設定の命令%COMMAND%
	ENDSELECT
CASE "ADD_BY_NAME", "TIMES_BY_NAME", "PERCENT_BY_NAME", "PPM_BY_NAME"
	SIF !STRLENS(ARGS:0)
		THROW 変数名を設定して下さい
	TEMP_ID = FINDELEMENT(VAR_NAME, ARGS:0, 1, , 1)
	SIF TEMP_ID <= 0
		THROW 存在しない変数を参照しました%ARGS:0%
	
	SELECTCASE COMMAND
	;加算、もちろん負数も可能
	CASE "ADD_BY_NAME"
		VAR_INT:TEMP_ID += ARG:0
	;乗算、小数値は渡せないので注意
	CASE "TIMES_NAME"
		VAR_INT:TEMP_ID *= ARG:0
	;指定変数をARGパーセントにする
	CASE "PERCENT_NAME"
		VAR_INT:TEMP_ID *= ARG:0
		VAR_INT:TEMP_ID /= 100
	;PPM＝百万分率
	CASE "PPM_NAME"
		VAR_INT:TEMP_ID *= ARG:0
		VAR_INT:TEMP_ID /= 1000000
	CASEELSE
		THROW 未設定の命令%COMMAND%
	ENDSELECT
CASEELSE
	THROW 未設定の命令%COMMAND%
ENDSELECT
RETURNF



;-----------------------------------------------
;一時変数取得関数
;-----------------------------------------------
;式中関数
;IDを渡す時でも"3"など文字列で渡さないとエラーを吐く
;INT/STRは「変数の中身」でも「第一引数の型」でもないことに注意
;これは「戻り値の型」である（つまりTOINT()の省略がしたかった）
;戻り値がSTRとなるのはGET_NAMEとGET_VALUEの中身がSTRの時だけ
@TEMP_INT(COMMAND, ARGS:0)
#FUNCTION
#DIMS COMMAND
RETURNF TOINT(TEMP_GET(COMMAND, ARGS:0))

@TEMP_STR(COMMAND, ARGS:0)
#FUNCTIONS
#DIMS COMMAND
RETURNF TEMP_GET(COMMAND, ARGS:0)

@TEMP_GET(COMMAND = "GET_VALUE", ARGS:0)
#FUNCTIONS
#DIMS COMMAND
SELECTCASE COMMAND
CASE "GET_TOTAL"
	RETURNF TEMP_STOCK("GET_TOTAL")
CASE "GET_VALUE"
	;数字っぽければIDとみなす
	IF ISNUMERIC(ARGS:0)
		RETURNF TEMP_STOCK("GET_VALUE_BY_ID", , , TOINT(ARGS:0))
	ELSE
		RETURNF TEMP_STOCK("GET_VALUE_BY_NAME", ARGS:0)
	ENDIF
;変数名から変数のIDを返す
;存在しない時は0
CASE "GET_ID"
	RETURNF TEMP_STOCK("GET_ID", ARGS:0)
;ARGS:0の含まれる変数名の数を返す
CASE "GET_CNT_NAME"
	RETURNF TEMP_STOCK("GET_CNT_NAME", ARGS:0)
;変数の位置から変数名を返す
;存在しない時は空の文字列を返す
CASE "GET_NAME"
	RETURNF TEMP_STOCK("GET_NAME", , , TOINT(ARGS:0))
CASEELSE
	THROW 不明なコマンド%COMMAND%
ENDSELECT


;-----------------------------------------------
;RETURN系関数
;-----------------------------------------------
;式中関数
;変数名もしくはIDを参照してその変数の中身（INTorSTR）を取得する関数
;F関数でRETURN系というのもちとおかしいが命名センスが死んでるだけなので気にするな
;この関数の特徴は取得後に参照元の変数を消去する点、つかう機会は多いはず
;変数作る一方じゃすぐいっぱいになっちゃうからね
;他の情報で取得直後に消すという処理が必要と思えないのでVALUE専用

@TEMP_RE_INT(ARGS)
#FUNCTION
LOCAL = TEMP_INT("GET_VALUE", ARGS)
CALLF TEMP_VARCLEAR(ARGS)
RETURNF LOCAL

@TEMP_RE_STR(ARGS)
#FUNCTIONS
LOCALS = %TEMP_STR("GET_VALUE", ARGS)%
CALLF TEMP_VARCLEAR(ARGS)
RETURNF LOCALS

;-----------------------------------------------
;代入・初期化系関数
;-----------------------------------------------
;CALLFで使用
;一時変数作成関数
;これがなけりゃはじまらない
;変数作成と初期値の設定
;すでに存在するとエラー
;MAKE_INTでINT変数、MAKE_STRでSTR変数を作成する
@MAKE_INT(V_NAME, V_INT)
#FUNCTIONS
#DIMS V_NAME
#DIM  V_INT
RETURNF TEMP_VARMAKE(V_NAME, , V_INT)

@MAKE_STR(V_NAME, V_STR)
#FUNCTIONS
#DIMS V_NAME
#DIMS V_STR
RETURNF TEMP_VARMAKE(V_NAME, V_STR)

@TEMP_VARMAKE(V_NAME, V_STR, V_INT)
#FUNCTIONS
#DIMS V_NAME
#DIMS V_STR
#DIM  V_INT
RETURNF TEMP_STOCK("VARMAKE", V_NAME, V_STR, V_INT)


;代入関数
;CALLFで使用
;変数が存在しないとエラー
;STRとINTの両方のVALUEに情報が入ってる時はSTRが返ってくる
;
;代入関数使いたい時は
;	CALLF SET_INT/STR
;で使って下さい
@SET_INT(V_NAME, V_INT)
#FUNCTION
#DIMS V_NAME
#DIM  V_INT
RETURNF TOINT(TEMP_VARSET(V_NAME, , V_INT))

@SET_STR(V_NAME, V_STR)
#FUNCTIONS
#DIMS V_NAME
#DIMS V_STR
RETURNF TEMP_VARSET(V_NAME, V_STR)

@TEMP_VARSET(V_NAME, V_STR, V_INT)
#FUNCTIONS
#DIMS V_NAME
#DIMS V_STR
#DIM  V_INT
;数字っぽければIDとみなす
IF ISNUMERIC(V_NAME)
	RETURNF TEMP_STOCK("VARSET_BY_ID", , V_STR, TOINT(V_NAME), V_INT)
ELSE
	RETURNF TEMP_STOCK("VARSET_BY_NAME", V_NAME, V_STR, V_INT)
ENDIF

;変数の初期化関数
@TEMP_VARCLEAR(ARGS:0, OP = "NORMAL")
#FUNCTIONS
#DIMS OP
SELECTCASE OP
;通常は変数名、もしくはIDに一致する変数のみを消去
CASE "NORMAL"
	IF ISNUMERIC(ARGS:0)
		RETURNF TEMP_STOCK("VARCLEAR_BY_ID", , , TOINT(ARGS:0))
	ELSE
		RETURNF TEMP_STOCK("VARCLEAR_BY_NAME", ARGS:0)
	ENDIF
;変数名にキーワードを含むものを消去、巻き込み注意
CASE "KEY"
		RETURNF TEMP_STOCK("VARCLEAR_BY_KEYWORD", ARGS:0)
;全消去、強力すぎてあまり多用はできない
CASE "ALL"
		RETURNF TEMP_STOCK("ALLCLEAR")
ENDSELECT

;-----------------------------------------------
;算術系関数
;-----------------------------------------------
;正直、存在意義が微妙な気がするが一応つくっておくよ
;CALLFで使用
;COMMANDはADD, TIMES, PERCENT, PPM
;PPMはいくらでも増やせるよって例で冗談で作った
@TEMP_METH(V_NAME, COMMAND, ARG:0)
#FUNCTIONS
#DIMS V_NAME
#DIMS COMMAND
IF ISNUMERIC(V_NAME)
	RETURNF TEMP_STOCK(@"%COMMAND%_BY_ID", , , TOINT(V_NAME), ARG:0)
ELSE
	RETURNF TEMP_STOCK(@"%COMMAND%_BY_NAME", V_NAME, , ARG:0)
ENDIF
